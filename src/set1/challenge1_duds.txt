pub fn hex_to_64_a(hex_str: &str) -> String {
    let chars: Vec<u8> = hex_str
        .bytes()
        .collect::<Vec<u8>>()
        .chunks(2)
        .map(|x| u8::from_str_radix(str::from_utf8(x).unwrap(), 16).unwrap())
        .collect();
    let strs = str::from_utf8(&chars).unwrap();

    base64::encode(strs)
}

pub fn hex_to_64_b(hex_str: &str) -> String {
    let chars: Vec<u8> = hex_str
        .bytes()
        .collect::<Vec<u8>>()
        .chunks(2)
        .map(|x| str::from_utf8(x).unwrap())
        .map(|x| u8::from_str_radix(x, 16).unwrap())
        .collect();
    let strs = str::from_utf8(&chars).unwrap();

    base64::encode(strs)
}

pub fn hex_to_64_c(hex_str: &str) -> String {
    let mut prev_char: u8 = 0;
    let strs = hex_str
        .bytes()
        .enumerate()
        .fold(String::new(), |acc, (index, chr)| {
            if index % 2 == 0 {
                prev_char = raw_byte_to_char_byte(chr);
                acc
            } else {
                let two_hex: u8 = prev_char * 16 + raw_byte_to_char_byte(chr);
                format!("{}{}", acc, two_hex as char)
            }
        });

    base64::encode(strs)
}

pub fn hex_to_64_d(hex_str: &str) -> String {
    let mut prev_char: u8 = 0;
    let strs = hex_str
        .bytes()
        .enumerate()
        .fold(Vec::new(), |mut acc, (index, byte)| {
            if index % 2 == 0 {
                prev_char = raw_byte_to_char_byte(byte);
            } else {
                let two_hex: u8 = prev_char * 16 + raw_byte_to_char_byte(byte);
                acc.push(two_hex);
            }
            acc
        });

    base64::encode(strs)
}


pub fn hex_to_64_a(hex_str: &str) -> String {
    let mut prev_char: u8 = 0;
    let strs = hex_str
        .bytes()
        .enumerate()
        .fold(String::new(), |mut acc, (index, byte)| {
            if index % 2 == 0 {
                prev_char = raw_byte_to_char_byte(byte);
            } else {
                let two_hex: u8 = prev_char * 16 + raw_byte_to_char_byte(byte);
                acc.push(two_hex as char);
            }
            acc
        });

    base64::encode(strs)
}

pub fn hex_to_64_b(hex_str: &str) -> String {
    let capacity = hex_str.len() / 2;

    let mut prev_char: u8 = 0;
    let strs = hex_str.bytes().enumerate().fold(
        String::with_capacity(capacity),
        |mut acc, (index, byte)| {
            if index % 2 == 0 {
                prev_char = raw_byte_to_char_byte(byte);
            } else {
                let two_hex: u8 = prev_char * 16 + raw_byte_to_char_byte(byte);
                acc.push(two_hex as char);
            }
            acc
        },
    );

    base64::encode(strs)
}

// best one
pub fn hex_str_to_base_64_str(hex_str: &str) -> String {
    let capacity = hex_str.len() / 2;

    let mut prev_char: u8 = 0;
    let strs =
        hex_str
            .bytes()
            .enumerate()
            .fold(Vec::with_capacity(capacity), |mut acc, (index, byte)| {
                if index % 2 == 0 {
                    prev_char = raw_byte_to_char_byte(byte);
                } else {
                    let two_hex: u8 = prev_char * 16 + raw_byte_to_char_byte(byte);
                    acc.push(two_hex);
                }
                acc
            });

    base64::encode(strs)
}

fn raw_byte_to_char_byte(raw_byte: u8) -> u8 {
    match raw_byte {
        // 48..=57 => raw_byte - 48,
        // 97..=102 => raw_byte - 97 + 10,
        // 65..=70 => raw_byte - 65 + 10,
        b'0'..=b'9' => raw_byte - b'0',
        b'a'..=b'f' => raw_byte - b'a' + 10,
        b'A'..=b'F' => raw_byte - b'A' + 10,
        _ => panic!(format!("{} is not a valid hex char", raw_byte)),
    }
}


